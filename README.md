# KripkeModelChecker
A simple parse for Kripke structure and its model checking operations. This project was built towards partial completion of requirements of a course namely, Formal Methods in Software Engineering. 


## Compiler
Built using Compiler C++11 

## Data Structure
The Kripke Structure (KS) in the attached code, is an instance of a class with 2 data members :

• A set containing pairs of integers, std::set<std::pair<state_id, state_id>> state_src . This is used to hold the arcs present in the given KS.

• An integer, num_srcs . This is used to hold the total number of states in the given KS 

The std::set data structure sorts its containing pair elements, first by the first element of the pairs and then by the second element of the pairs, such as : {(0, 1), (1, 1), (1, 2), (2, 0), (2, 2)}

The set of states are stored using the std::set data structure, which contains integer values. The class state state is a typedef alias for std::set<int>. The set of states are always sorted, by the property of the data structure. An example set of states of a KS with maximum 4 states can be given as :
{0, 2, 3}

## Labelling Algorithms
The labelling algorithms have been implemented in the following manner (assuming: sset is an operand for unary operations ; sset1,sset2 are operancds forbinary operations and rset stores result of an operation) :
• NOT : An iterator is used to traverse through all those arcs wherein the source node is unvisited. Those source nodes which are not found in sset are placed into rset.• OR : rset inserts elements of both sset1 and sset2 into itself, to represent union of two sets.

• AND : rset is generated by taking NOT of the OR, which is calculated with operands NOT of sset1 and NOT of sset2.

• IMPLIES : rset is generated by taking the OR, of operands NOT of sset1 and sset2.

• EX : An iterator is used to traverse through all those arcs in the KS. If a source node’s paired element (any one) is present in sset, then the node is added into rset

• AF : The algorithm 4.5.5 from the notes for Chapter 4 is implemented to get the rset

• EG : The rset is obtained by taking NOT of the AF, on operand set resulting from NOT of
sset

• EU : The algorithm 4.5.8 from the notes for Chapter 4 is implemented to get the rset

• AU : This is implemented using the equivalence formula given (Property 4.6) in the notes for chapter 4. This utilises the other labelling algorithms implemented so far.

• AX : rset is generated by taking NOT of the EX, on operand set resulting from NOT of sset

• EF : The rset is obtained by performing EU with first operand as set of all states and second operand as sset 1

• AG : The rset is obtained by taking NOT of the EF, on operand set resulting from NOT of sset


## Error Handling
Errors that are handled by the method finish() are:

• This method checks that all the states in the given KS have at least one outgoing edge. If
not, it returns false signifying error.

• This method checks that all the states are valid states by checking if they lie within the
range [0, n − 1] where n is the max. no. of states. If not, it returns false signifying error.
 
